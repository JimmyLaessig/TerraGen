\documentclass[a4paper,10pt]{article}
\usepackage[german]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{graphicx}




\begin{document}

\author{Bernhard Rainer 0828592 \\
	}

\title{186.166 Entwurf und Programmierung einer Rendering-Engine,\\
	Technischer Bericht - TerraGen}

\maketitle

\section*{Übersicht}
Ziel dieser Aufgabe ist es, eine interaktive Rendering-Engine zu programmieren, die es dem User ermöglicht selbst Geometrie zu erstellen und aktiv verändern. In diesem Beispiel ist ein interaktiver Terrain-Renderer implementiert, mit dem der User zur Laufzeit verschiedene Terrains, basierend auf einer Heightmap, generieren und verändern kann. 
Da es sich bei Terrains zumeinst um großflächige Areale handelt werden hier einige Techniken angewendet, die die Skalierung und Detailierung der Geometrie unterstützen. 

\section*{Framework}

\section*{Geometrie}
Das Basis-Geometrie-Objekt ist ein simples 10x10 Grid mit 200 Triangles, eine Einheit enspricht einem Meter. Wird das Terrain skaliert, wird dieses Grid wiederholt an nebeneinander liegenden Positionen gezeichnet, sodass eine homogene Fläche entsteht. Anhand der Vertex-Position im Grid, sowie der relativen Position der Grids zueinander, können Texturkoordinaten einfach berechnet und skaliert werden. 

\section*{Tesselierung}
Eine Grid-Auflösung von einem Meter ist für detailierte Landschaften oftmals nicht ausreichend. Daher wird, relativ zur Kamera, das Terrain in feinere Dreiecke unterteilt. Diesen Vorgang heißt Tesselierung. Hierzu werden dynamisch  Tesselierungslevel, basierend auf der Distanz des Dreiecks zur Kamera, berechnet. Diese Level entscheiden, wie oft das Dreieck unterteilt wird. Diese feinere Unterteilung erlaubt ein feineres Sampling der Höhentextur (Heightmap). 

\section*{Heightmap}
Die Heightmap bestimmt pro Vertex die Höhe der Geometrie entlang der y-Achse. Hierzu wird die Textur in regelmäßigen Abständen ausgelesen, sodass ein kontinuierlicher Terrain-Verlauf entsteht. Wird das Terrain skaliert, verringern sich die Abstände und die Auflösung wird höher. Selbiges trifft ebenfalls auf die Tesselierung zu.

Die Heightmap wird erstellt mit Hilfe von libnoise~\cite{libnoise} erstellt. Hierzu wird Perlin-Noise von verschiedenen Stärken genutzt um sowohl eine grobe Struktur, als auch eine feinere Detailierung der Landschaft zu gewährleisten. 

\subsection*{Erstellung einer Heightmap}
\begin{itemize}
\item Terrain Frequency: bestimmt die grobe Struktur des Terrains
\item Persistence: bestimmt, wie schnell sich die Basisfrequenz zwischen den Oktaven verringert
\item Bump Frequency: bestimmt die Frequenz der Detailierung des Terrains
\item Bias: Reduziert oder erhöht Erhebungen
\item Scale: Skalierung der feinen Struktur
\end{itemize}

Zusätzlich kann eine beliebige Textur als Heightmap eingelesen werden.

\section*{Texturierung und Schattierung}

Für eine realistische Darstellung sind Texturierung und Schattierung unabdingbar. Hierzu ist es notwendig, den Normalvektor pro Vertex, basierend auf den Höhendaten, zu berechnen. In diesem Beispiel wird ein 4-Sample-Cross-Filter verwendet. Die Differenzen der Höhenwerte in x- bzw. in z-Richtung der jeweiligen Vor-und Nachfolger ergeben die einzelnen Werte der Normalen. 
Diese Normale wird für die Schattierung benutzt. 

In diesem einfachen Programm wird zwischen einer Stein-Textur für steile Abhänge, sowie einer Gras-Textur für flache Ebenen unterschieden. Basierend auf der Neigung der Normalen wird zwischen den zwei Texturen unterschieden, oder interpoliert. Die Neigung berechnet sich aus Eins minus y-Komponente der Normalen. 

\section*{Navigation}
Die Kamera kann mittels der Maus bewegt werden, solange die rechte Maustaste gedrückt ist. Das Mausrad bewegt die Kamera vorwärts/rückwärts. Alternativ kann die Kamera ebenfalls mit den WASD-Tasten bewegt werden.

\section*{Evaluierung}




\bibliographystyle{unsrt}
\bibliography{references}

\end{document}